package main

import (
	"bytes"
	"io"
	"io/ioutil"
	"log"
	"net/http"

	"github.com/elazarl/goproxy"
	"github.com/nohajc/kodi-scraper-proxy/internal/filter"
	"github.com/nohajc/kodi-scraper-proxy/pkg/api"
)

// NewProxyWithScraperAdapters returns new HTTP proxy server with the given scraper adapters
func NewProxyWithScraperAdapters(adapters ...api.ResponseAdapter) *goproxy.ProxyHttpServer {
	proxy := goproxy.NewProxyHttpServer()

	proxy.OnResponse().DoFunc(func(resp *http.Response, ctx *goproxy.ProxyCtx) *http.Response {
		var reqBodyBuf bytes.Buffer
		io.Copy(&reqBodyBuf, ctx.Req.Body)
		reqBody, _ := ioutil.ReadAll(&reqBodyBuf)
		log.Printf("Request: %s, %v\n", ctx.Req.URL.Path, reqBody)

		for _, adp := range adapters {
			if adp.AppliesTo(ctx.Req.Host) {
				return ResponseFilter(adp, resp, ctx)
			}
		}

		return resp
	})

	return proxy
}

// ResponseFilter modifies response from the scraper source to apply the new ordering
func ResponseFilter(adp api.ResponseAdapter, resp *http.Response, ctx *goproxy.ProxyCtx) *http.Response {
	reader, writer := io.Pipe()

	adp.ResponseBodyFilter(resp.Body, writer, ctx.Req.URL.Host, ctx.Req.URL.Path)
	resp.Body = reader

	return resp
}

func main() {
	shows := filter.LoadConfig("ordering.yaml")
	log.Printf("%+v\n", shows)

	proxy := NewProxyWithScraperAdapters(&filter.TMDBScraperOrderingAdapter{filter.NewOfflineOrderingMap(shows)})
	proxy.Verbose = false

	log.Fatal(http.ListenAndServe(":8080", proxy))
}
